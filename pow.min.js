class POW{constructor(n,e,t,s=!0){this.workers=[],this.challenge=t,this.difficulty=e,this.publicSalt=n,this.navigatorData=this.cloneObject(navigator,0),this.numeric=s,this.workerScript="\n        self.onmessage = async function(e) {\n            const { publicSalt, challenge, start, end, numeric, difficulty, clientNavigator } = e.data;\n\n            function compareObj(obj1, obj2, depth = 0) {\n                if (depth > 4) return \"\";\n                let mismatches = [];\n                for (let key in obj1) {\n                    if (key === \"rtt\") continue;\n                    if (typeof obj1[key] === \"function\") continue;\n                    if (typeof obj1[key] === \"object\" && obj1[key] !== null) {\n                        const sub = compareObj(obj1[key], obj2[key], depth + 1);\n                        if (sub) mismatches.push(sub);\n                    } else if (obj1[key] !== obj2[key]) {\n                        mismatches.push(key);\n                    }\n                }\n                return mismatches.join(\", \");\n            }\n\n            function incrementHexString(str) {\n                const chars = '0123456789abcdef';\n                let carry = 1;\n                let res = '';\n                for (let i = str.length - 1; i >= 0; i--) {\n                    let index = chars.indexOf(str[i]) + carry;\n                    if (index >= chars.length) {\n                        index = 0;\n                        carry = 1;\n                    } else {\n                        carry = 0;\n                    }\n                    res = chars[index] + res;\n                }\n                return carry ? '0' + res : res;\n            }\n\n            function getStringByIndex(index, length) {\n                const chars = '0123456789abcdef';\n                let res = '';\n                for (let i = 0; i < length; i++) {\n                    res = chars[index % chars.length] + res;\n                    index = Math.floor(index / chars.length);\n                }\n                return res.padStart(length, '0');\n            }\n\n            async function sha256(message) {\n                const msgBuffer = new TextEncoder().encode(message);\n                const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);\n                const hashArray = Array.from(new Uint8Array(hashBuffer));\n                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n            }\n\n            let resp = { match: compareObj(navigator, clientNavigator), solution: \"\", access: \"\" };\n\n            if (numeric) {\n                for (let i = start; i <= end; i++) {\n                    if ((await sha256(publicSalt + i)) === challenge) {\n                        resp.solution = i;\n                        resp.access = await sha256(i.toString() + publicSalt);\n                        self.postMessage(resp);\n                        self.close();\n                        return;\n                    }\n                }\n            } else {\n                for (let i = start; i <= end; i++) {\n                    let current = getStringByIndex(i, difficulty);\n                    if ((await sha256(publicSalt + current)) === challenge) {\n                        resp.solution = current;\n                        resp.access = await sha256(current + publicSalt);\n                        self.postMessage(resp);\n                        self.close();\n                        return;\n                    }\n                }\n            }\n\n            self.postMessage(resp);\n            self.close();\n        };\n        "}cloneObject(n,e){let t={};if(e>4)return t;for(let s in n)"object"!=typeof n[s]||null===n[s]||n[s]instanceof Function?"function"==typeof n[s]||n[s]instanceof HTMLElement||(t[s]=n[s]):t[s]=this.cloneObject(n[s],e+1);return t}spawnWorker(n,e,t){return new Promise((s=>{const r=new Worker(n);this.workers.push(r),r.onmessage=n=>{const e=n.data;""!==e.solution?(this.workers.forEach((n=>n.terminate())),s(e)):s(null)},r.postMessage({challenge:this.challenge,publicSalt:this.publicSalt,start:e,end:t,numeric:this.numeric,difficulty:this.difficulty,clientNavigator:this.navigatorData})}))}async Solve(){const n=Math.min(navigator.hardwareConcurrency||2,16);console.log(`🤔 Starting solve with ${n} workers`);const e=this.numeric?this.difficulty:Math.pow(16,this.difficulty),t=Math.ceil(e/n),s=new Blob([this.workerScript],{type:"text/javascript"}),r=URL.createObjectURL(s),i=[];for(let n=0;n<e;n+=t)i.push(this.spawnWorker(r,n,Math.min(n+t-1,e-1)));try{const n=Date.now(),e=await Promise.any(i),t=Date.now();return console.log("🥳 Heureka",e),console.log("Solved in:",(t-n)/1e3,"seconds"),e}catch(n){return console.log("🕵️ No worker found a solution",n),null}}}
