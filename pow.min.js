class POW{constructor(t,n,e,i=!0){this.workers=[],this.challenge=e,this.difficulty=n,this.publicSalt=t,this.navigatorData=this.cloneObject(navigator,0),this.numeric=i,this.workerScript='\n        importScripts(\'https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.0.0/crypto-js.min.js\');\n\n        self.onmessage = function(e) {\n            const { publicSalt, challenge, start, end, numeric, difficulty, clientNavigator } = e.data;\n\n            function compareObj(obj1, obj2, depth = 0) {\n                if (depth > 4) return "";\n                let mismatches = [];\n                for (let key in obj1) {\n                    if (key === "rtt") continue;\n                    if (typeof obj1[key] === "function") continue;\n                    if (typeof obj1[key] === "object" && obj1[key] !== null) {\n                        const sub = compareObj(obj1[key], obj2[key], depth + 1);\n                        if (sub) mismatches.push(sub);\n                    } else if (obj1[key] !== obj2[key]) {\n                        mismatches.push(key);\n                    }\n                }\n                return mismatches.join(", ");\n            }\n\n            function getStringByIndex(index, length) {\n                const chars = \'0123456789abcdef\';\n                let res = \'\';\n                for (let i = 0; i < length; i++) {\n                    res = chars[index % chars.length] + res;\n                    index = Math.floor(index / chars.length);\n                }\n                return res.padStart(length, \'0\');\n            }\n\n            let resp = { match: compareObj(navigator, clientNavigator), solution: "", access: "" };\n\n            if (numeric) {\n                for (let i = start; i <= end; i++) {\n                    if (CryptoJS.SHA256(publicSalt + i).toString() === challenge) {\n                        resp.solution = i;\n                        resp.access = CryptoJS.SHA256(i.toString() + publicSalt).toString();\n                        self.postMessage(resp);\n                        self.close();\n                        return;\n                    }\n                }\n            } else {\n                for (let i = start; i <= end; i++) {\n                    let current = getStringByIndex(i, difficulty);\n                    if (CryptoJS.SHA256(publicSalt + current).toString() === challenge) {\n                        resp.solution = current;\n                        resp.access = CryptoJS.SHA256(current + publicSalt).toString();\n                        self.postMessage(resp);\n                        self.close();\n                        return;\n                    }\n                }\n            }\n\n            self.postMessage(resp);\n            self.close();\n        };\n        '}cloneObject(t,n){let e={};if(n>4)return e;for(let i in t)"object"!=typeof t[i]||null===t[i]||t[i]instanceof Function?"function"==typeof t[i]||t[i]instanceof HTMLElement||(e[i]=t[i]):e[i]=this.cloneObject(t[i],n+1);return e}spawnWorker(t,n,e){return new Promise((i=>{const o=new Worker(t);this.workers.push(o),o.onmessage=t=>{const n=t.data;""!==n.solution?(i(n),setTimeout((()=>this.workers.forEach((t=>t.terminate()))),0)):i(null)},o.postMessage({challenge:this.challenge,publicSalt:this.publicSalt,start:n,end:e,numeric:this.numeric,difficulty:this.difficulty,clientNavigator:this.navigatorData})}))}async Solve(){const t=Math.min(navigator.hardwareConcurrency||2,16);console.log(`ü§î Starting solve with ${t} workers`);const n=this.numeric?this.difficulty:Math.pow(16,this.difficulty),e=Math.ceil(n/t),i=new Blob([this.workerScript],{type:"text/javascript"}),o=URL.createObjectURL(i),s=[];for(let t=0;t<n;t+=e)s.push(this.spawnWorker(o,t,Math.min(t+e-1,n-1)));try{const t=Date.now(),n=await Promise.race(s.map((t=>t.catch((()=>null))))),e=Date.now();if(!n)throw new Error("No solution found");return console.log("ü•≥ Heureka",n),console.log("Solved in:",(e-t)/1e3,"seconds"),n}catch(t){return console.log("üïµÔ∏è No worker found a solution",t),null}}}
