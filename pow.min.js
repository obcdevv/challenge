class POW{constructor(n,t,e,i=!0){this.workers=[],this.challenge=e,this.difficulty=t,this.publicSalt=n,this.navigatorData=this.cloneObject(navigator,0),this.numeric=i,this.workerScript='\n        importScripts(\'https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.0.0/crypto-js.min.js\');\n\n        self.onmessage = function(e) {\n            const { publicSalt, challenge, start, end, numeric, difficulty, clientNavigator } = e.data;\n\n            function compareObj(obj1, obj2, depth = 0) {\n                if (depth > 4) return "";\n                let mismatches = [];\n                for (let key in obj1) {\n                    if (key === "rtt") continue;\n                    if (typeof obj1[key] === "function") continue;\n                    if (typeof obj1[key] === "object" && obj1[key] !== null) {\n                        const sub = compareObj(obj1[key], obj2[key], depth + 1);\n                        if (sub) mismatches.push(sub);\n                    } else if (obj1[key] !== obj2[key]) {\n                        mismatches.push(key);\n                    }\n                }\n                return mismatches.join(", ");\n            }\n\n            function getStringByIndex(index, length) {\n                const chars = \'0123456789abcdef\';\n                let res = \'\';\n                for (let i = 0; i < length; i++) {\n                    res = chars[index % chars.length] + res;\n                    index = Math.floor(index / chars.length);\n                }\n                return res.padStart(length, \'0\');\n            }\n\n            let resp = { match: compareObj(navigator, clientNavigator), solution: "", access: "" };\n\n            if (numeric) {\n                for (let i = start; i <= end; i++) {\n                    if (CryptoJS.SHA256(publicSalt + i).toString() === challenge) {\n                        resp.solution = i;\n                        resp.access = CryptoJS.SHA256(i.toString() + publicSalt).toString();\n                        self.postMessage(resp);\n                        self.close();\n                        return;\n                    }\n                }\n            } else {\n                for (let i = start; i <= end; i++) {\n                    let current = getStringByIndex(i, difficulty);\n                    if (CryptoJS.SHA256(publicSalt + current).toString() === challenge) {\n                        resp.solution = current;\n                        resp.access = CryptoJS.SHA256(current + publicSalt).toString();\n                        self.postMessage(resp);\n                        self.close();\n                        return;\n                    }\n                }\n            }\n\n            self.postMessage(resp);\n            self.close();\n        };\n        '}cloneObject(n,t){let e={};if(t>4)return e;for(let i in n)"object"!=typeof n[i]||null===n[i]||n[i]instanceof Function?"function"==typeof n[i]||n[i]instanceof HTMLElement||(e[i]=n[i]):e[i]=this.cloneObject(n[i],t+1);return e}spawnWorker(n,t,e){return new Promise((i=>{const s=new Worker(n);this.workers.push(s),s.onmessage=n=>{const t=n.data;""!==t.solution?(this.workers.forEach((n=>n.terminate())),i(t)):i(null)},s.postMessage({challenge:this.challenge,publicSalt:this.publicSalt,start:t,end:e,numeric:this.numeric,difficulty:this.difficulty,clientNavigator:this.navigatorData})}))}async Solve(){const n=Math.min(navigator.hardwareConcurrency||2,16);console.log(`🤔 Starting solve with ${n} workers`);const t=this.numeric?this.difficulty:Math.pow(16,this.difficulty),e=Math.ceil(t/n),i=new Blob([this.workerScript],{type:"text/javascript"}),s=URL.createObjectURL(i),o=[];for(let n=0;n<t;n+=e)o.push(this.spawnWorker(s,n,Math.min(n+e-1,t-1)));try{const n=Date.now(),t=await Promise.any(o),e=Date.now();return console.log("🥳 Heureka",t),console.log("Solved in:",(e-n)/1e3,"seconds"),t}catch(n){return console.log("🕵️ No worker found a solution",n),null}}}
